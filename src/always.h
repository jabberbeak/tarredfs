/*
    Copyright (C) 2016-2018 Fredrik Öhrström

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DEFS_H
#define DEFS_H

// Include the defines generated by the configure script.
#include"config.h"

#include <assert.h>
#include <memory>

#define BEAK_VERSION 0.7
#define BEAK_VERSION_INT 7

#define supportedVersion(x) (x==BEAK_VERSION_INT)

class ReturnCode
{
public:
    bool isOk() { return val == 0; }
    bool isErr() { return val != 0; }

    static ReturnCode OK;
    static ReturnCode ERR;
    int toInteger() { return val; }
    const char *toString() { return val==0?"ok":"err"; }

private:
    ReturnCode(int v) : val(v) { }
    int val {};
};

// The RC return code type is used instead of an integer typedef.
// This is necessary to prevent all those annoying automatic
// to integer conversions that introduce bugs in the code.
typedef ReturnCode RC;

#define XSTR(s) STR(s)
#define STR(s) #s

#define DEFAULT_TARGET_TAR_SIZE 10ull*1024*1024;
#define DEFAULT_TAR_TRIGGER_SIZE 20ull*1024*1024;
#define DEFAULT_SPLIT_TAR_SIZE 100ull*1024*1024;

#if SIZEOF_TIME_T == 8
#define PRINTF_TIME_T "z"
#else
#define PRINTF_TIME_T "l"
#endif

#define call(A,B) ([A](){A->B();})
#define calll(A,B,T) ([A](T t){A->B(t);})

// The ptr template class is used to automatically acquire
// a copy of a unique_ptr, without the need for calling .get
template<class T>
class ptr {
    T *t {};

public:
    T* operator ->() { return t; }
    operator T*() { return t; }
    ptr() = default;
    ptr(T* p) : t(p) { }
    ptr(std::unique_ptr<T>& p) : t(p.get()) { }
    ptr(const ptr& that) { t = that.t; }
};


#endif
